#!/usr/bin/env python

import vake
from vake import xsys
from vake import xos
from vake import xpath
from vake import xlogging


class Xake:
    """
    CLI launcher
    """

    #
    # Constants
    #
    ACTION_INSTALL      = "install"
    ACTION_UNINSTALL    = "uninstall"
    ACTION_STATUS       = "status"
    ACTION_COMPLETION   = "completion"

    TARGET_DOTFILE      = "dotfile"
    TARGET_BREW         = "brew"
    TARGET_CASK         = "cask"
    TARGET_GEM          = "gem"
    TARGET_NPM          = "npm"

    COMPLETION_FILE_SRC = "vake/template/_xake"
    COMPLETION_FILE_DST = "default/zsh-completions/_xake"

    #
    # Methods
    #
    def __init__(self):
        """
        Initialize application
        """
        self.parser = self.__parser()
        return

    def run(self, args):
        """
        Run application
        """

        # sack
        sack = self.__sack(args)
        sack.logger = self.__logger(sack)

        # completion
        if sack.action == Xake.ACTION_COMPLETION:
            self.completion(sack)
            xsys.exit(0)

        # action
        for command in self.__commands(sack):
            command.run()

        xsys.exit(0)

    def completion(self, sack):
        """
        Show messages for completion

        :param sack: Sack
        """

        from mako.template import Template

        template = Template(filename=Xake.COMPLETION_FILE_SRC, input_encoding="utf-8", output_encoding="utf-8")

        rendered = template.render(
            options=self.parser._optionals._group_actions,
            actions=self.actions(),
            targets=self.targets(),
        )

        with open(Xake.COMPLETION_FILE_DST, 'w') as dst:
            dst.write(rendered)

        xsys.stdout.write(rendered)
        return

    @classmethod
    def actions(cls):
        return [
            Xake.ACTION_INSTALL,
            Xake.ACTION_UNINSTALL,
            Xake.ACTION_STATUS,
            Xake.ACTION_COMPLETION,
        ]

    @classmethod
    def targets(cls):
        return [
            Xake.TARGET_DOTFILE,
            Xake.TARGET_BREW,
            Xake.TARGET_CASK,
            Xake.TARGET_GEM,
            Xake.TARGET_NPM,
        ]

    @classmethod
    def __parser(cls):
        if xsys.version_info >= (2, 7, 0):
            return cls.__parser_27()
        else:
            return cls.__parser_26()

    @classmethod
    def __parser_27(cls):
        import argparse

        parser = argparse.ArgumentParser(formatter_class=lambda prog: argparse.HelpFormatter(prog, width=240))

        parser.add_argument("-n", "--dry-run", dest="dry_run", action="store_true",
                            help="Do not execute commands actually")

        parser.add_argument("-v", "--verbose", dest="verbose", action="store_true",
                            help="Show verbose messages")

        parser.add_argument("action", type=str,
                            help="Action to perform: (%s)" % "|".join(cls.actions()))

        parser.add_argument("target", type=str, nargs="*", default=["dotfile"],
                            help="Target for action: (%s)" % "|".join(cls.targets()))

        return parser

    @classmethod
    def __parser_26(cls):
        import optparse

        parser = optparse.OptionParser()

        parser.add_option("-n", "--dry-run", dest="dry_run", action="store_true",
                          help="Do not execute commands actually")

        parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                          help="Show verbose messages")

        return parser

    def __sack(self, args):
        """
        Package sack

        :param args: Arguments
        :return: Knapsack
        """
        if xsys.version_info >= (2, 7, 0):
            sack = self.__sack_27(args)
        else:
            sack = self.__sack_26(args)

        return sack

    def __sack_27(self, args):

        namespace = self.parser.parse_args(args)

        sack = Sack()
        sack.action = namespace.action
        sack.targets = namespace.target
        sack.dry_run = namespace.dry_run
        sack.verbose = namespace.verbose

        return sack

    def __sack_26(self, args):

        (opts, argv) = self.parser.parse_args(args)

        sack = Sack()
        sack.action = argv[0]
        sack.targets = argv[1:]
        sack.dry_run = opts.dry_run
        sack.verbose = opts.verbose

        return sack

    @classmethod
    def __logger(cls, sack):
        if sack.verbose:
            logging_level = xlogging.DEBUG
        else:
            logging_level = xlogging.EXEC

        formatter = xlogging.LabelFormatter()

        handler = xlogging.StreamHandler()
        handler.setLevel(logging_level)
        handler.setFormatter(formatter)

        logger = xlogging.getLogger(__name__)
        logger.setLevel(logging_level)
        logger.addHandler(handler)

        return logger

    @classmethod
    def __commands(cls, sack):
        if sack.action == Xake.ACTION_INSTALL:
            return cls.__commands_install(sack)

        if sack.action == Xake.ACTION_UNINSTALL:
            return cls.__commands_uninstall(sack)

        if sack.action == Xake.ACTION_STATUS:
            return cls.__commands_status(sack)

        return []

    @classmethod
    def __commands_install(cls, sack):

        modules = filter(lambda module: module is not None and module.Install is not None,
                         map(lambda target: cls.__module(target), sack.targets))

        commands = filter(lambda action: action is not None,
                          map(lambda module: module.Install(noop=sack.dry_run, logger=sack.logger), modules))

        return commands

    @classmethod
    def __commands_uninstall(cls, sack):

        modules = filter(lambda module: module is not None and module.Uninstall is not None,
                         map(lambda target: cls.__module(target), sack.targets))

        commands = filter(lambda action: action is not None,
                          map(lambda module: module.Uninstall(noop=sack.dry_run, logger=sack.logger), modules))

        return commands

    @classmethod
    def __commands_status(cls, sack):

        modules = filter(lambda module: module is not None and module.Status is not None,
                         map(lambda target: cls.__module(target), sack.targets))

        commands = filter(lambda action: action is not None,
                          map(lambda module: module.Status(noop=sack.dry_run, logger=sack.logger), modules))

        return commands

    @classmethod
    def __module(cls, target):
        if target == Xake.TARGET_DOTFILE:
            return vake.command.dotfile

        if target == Xake.TARGET_BREW:
            return vake.command.brew

        if target == Xake.TARGET_CASK:
            return vake.command.cask

        if target == Xake.TARGET_GEM:
            return vake.command.gem

        if target == Xake.TARGET_NPM:
            return vake.command.npm

        return None


class Sack:
    """
    Attributes store for application
    """

    def __init__(self):
        """
        Initialize sack
        """
        self.action = None
        self.targets = []
        self.dry_run = False
        self.verbose = False
        self.logger = None
        return

#
# Main process
#
if __name__ == "__main__":
    # change to script's directory
    xos.chdir(xpath.dirname(xpath.realpath(__file__)))

    # run application
    Xake().run(xsys.argv[1:])
