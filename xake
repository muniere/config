#!/usr/bin/env python

# 1st
import os
import sys
import logging

# 2nd
import vake
from vake import xos
from vake import xlogging


class Action:

    INSTALL = "install"
    UNINSTALL = "uninstall"
    STATUS = "status"
    COMPLETION = "completion"

    @classmethod
    def values(cls):
        return [
            cls.INSTALL,
            cls.UNINSTALL,
            cls.STATUS,
            cls.COMPLETION,
        ]


class Target:

    DOTFILE = "dotfile"
    BINFILE = "binfile"
    BREW = "brew"
    CASK = "cask"
    GEM = "gem"
    NPM = "npm"

    @classmethod
    def values(cls):
        return [
            cls.DOTFILE,
            cls.BINFILE,
            cls.BREW,
            cls.CASK,
            cls.GEM,
            cls.NPM,
        ]


class Commander:

    @classmethod
    def find(cls, target):
        if target == Target.DOTFILE:
            return vake.command.dotfile

        if target == Target.BREW:
            return vake.command.brew

        if target == Target.CASK:
            return vake.command.cask

        if target == Target.GEM:
            return vake.command.gem

        if target == Target.NPM:
            return vake.command.npm

        if target == Target.BINFILE:
            return vake.command.binfile

        return None


class Completion:
    SOURCE = "vake/template/_xake"
    DESTINATION = "default/zsh-completions/_xake"


class Context:
    """
    Attributes store for application
    """
    def __init__(self):
        """
        Initialize context
        """
        self.action = None
        self.targets = []
        self.dry_run = False
        self.verbose = False
        return

    def commands(self):
        if self.action == Action.INSTALL:
            logger = self.__make_logger()
            modules = [m for m in [Commander.find(t) for t in self.targets]]
            modules = [m for m in modules if m is not None and m.Install is not None]
            commands = [m.Install(noop=self.dry_run, logger=logger) for m in modules]
            commands = [c for c in commands if c is not None]
            return commands

        if self.action == Action.UNINSTALL:
            logger = self.__make_logger()
            modules = [m for m in [Commander.find(t) for t in self.targets]]
            modules = [m for m in modules if m is not None and m.Uninstall is not None]
            commands = [m.Uninstall(noop=self.dry_run, logger=logger) for m in modules]
            commands = [c for c in commands if c is not None]
            return commands

        if self.action == Action.STATUS:
            logger = self.__make_logger()
            modules = [m for m in [Commander.find(t) for t in self.targets]]
            modules = [m for m in modules if m is not None and m.Status is not None]
            commands = [m.Status(noop=self.dry_run, logger=logger) for m in modules]
            commands = [c for c in commands if c is not None]
            return commands

        return []

    def __make_logger(self):
        if self.verbose:
            logging_level = xlogging.DEBUG
        else:
            logging_level = xlogging.EXEC

        formatter = xlogging.LabelFormatter()

        handler = logging.StreamHandler()
        handler.setLevel(logging_level)
        handler.setFormatter(formatter)

        logger = logging.getLogger(__name__)
        logger.setLevel(logging_level)
        logger.addHandler(handler)

        return logger


class Parser:

    @classmethod
    def parse(cls, args):
        """
        Compose context for arguments

        :param args: Arguments
        :return: Context
        """
        if sys.version_info >= (2, 7, 0):
            return cls.__parse_argparse(args)
        else:
            return cls.__parse_optparse(args)

    @classmethod
    def options(cls):
        """
        Get possible options
        """
        if sys.version_info >= (2, 7, 0):
            return cls.__make_argparser()._optionals._group_actions
        else:
            return list()

    @classmethod
    def __parse_argparse(cls, args):
        parser = cls.__make_argparser()

        namespace = parser.parse_args(args)

        context = Context()
        context.action = namespace.action
        context.targets = namespace.target or ["dotfile", "binfile"]
        context.dry_run = namespace.dry_run
        context.verbose = namespace.verbose

        return context

    @classmethod
    def __parse_optparse(cls, args):
        parser = cls.__make_optparser()

        (opts, argv) = parser.parse_args(args)

        context = Context()
        context.action = argv[0]
        context.targets = argv[1:] or ["dotfile", "binfile"]
        context.dry_run = opts.dry_run
        context.verbose = opts.verbose

        return context

    @classmethod
    def __make_argparser(cls):
        import argparse

        parser = argparse.ArgumentParser(formatter_class=lambda prog: argparse.HelpFormatter(prog, width=240))
        parser.add_argument("-n", "--dry-run", dest="dry_run", action="store_true", help="Do not execute commands actually")
        parser.add_argument("-v", "--verbose", dest="verbose", action="store_true", help="Show verbose messages")
        parser.add_argument("action", type=str, help="Action to perform: (%s)" % "|".join(Action.values()))
        parser.add_argument("target", type=str, nargs="*", help="Target for action: (%s)" % "|".join(Target.values()))

        return parser

    @classmethod
    def __make_optparser(cls):
        import optparse

        parser = optparse.OptionParser(usage="Usage: %prog [options] <command> [<target> ...]")
        parser.add_option("-n", "--dry-run", dest="dry_run", action="store_true", help="Do not execute commands actually")
        parser.add_option("-v", "--verbose", dest="verbose", action="store_true", help="Show verbose messages")

        return parser


class CLI:
    """
    CLI launcher
    """

    def __init__(self):
        """
        Initialize application
        """
        pass

    def run(self, args):
        """
        Run application
        """

        # context
        context = Parser.parse(args)

        # completion
        if context.action == Action.COMPLETION:
            self.completion(context)
            sys.exit(0)

        # action
        for command in context.commands():
            command.run()

        sys.exit(0)

    def completion(self, context):
        """
        Show messages for completion

        :param context: Context
        """

        from mako.template import Template

        template = Template(
            filename=Completion.SOURCE,
            input_encoding="utf-8",
            output_encoding="utf-8"
        )

        rendered = template.render(
            options=Parser.options(),
            actions=Action.values(),
            targets=Target.values(),
        )

        with open(Completion.DESTINATION, 'w') as dst:
            dst.write(rendered)

        sys.stdout.write(rendered)
        return

#
# Main process
#
if __name__ == "__main__":
    # change to script's directory
    os.chdir(os.path.dirname(os.path.realpath(__file__)))

    # run application
    CLI().run(sys.argv[1:])
