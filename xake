#!/usr/bin/env python

import vake
from vake import xsys
from vake import xos
from vake import xpath
from vake import xlogging


class Xake:
    """
    CLI launcher
    """

    #
    # Constants
    #
    ACTION_INSTALL      = "install"
    ACTION_UNINSTALL    = "uninstall"
    ACTION_STATUS       = "status"
    ACTION_COMPLETION   = "completion"

    TARGET_DOTFILE      = "dotfile"
    TARGET_BINFILE      = "binfile"
    TARGET_BREW         = "brew"
    TARGET_CASK         = "cask"
    TARGET_GEM          = "gem"
    TARGET_NPM          = "npm"

    COMPLETION_FILE_SRC = "vake/template/_xake"
    COMPLETION_FILE_DST = "default/zsh-completions/_xake"

    #
    # Methods
    #
    def __init__(self):
        """
        Initialize application
        """
        self.parser = self.__parser()
        return

    def run(self, args):
        """
        Run application
        """

        # context
        context = self.__context(args)
        context.logger = self.__logger(context)

        # completion
        if context.action == Xake.ACTION_COMPLETION:
            self.completion(context)
            xsys.exit(0)

        # action
        for command in self.__commands(context):
            command.run()

        xsys.exit(0)

    def completion(self, context):
        """
        Show messages for completion

        :param context: Context
        """

        from mako.template import Template

        template = Template(filename=Xake.COMPLETION_FILE_SRC, input_encoding="utf-8", output_encoding="utf-8")

        rendered = template.render(
            options=self.parser._optionals._group_actions,
            actions=self.actions(),
            targets=self.targets(),
        )

        with open(Xake.COMPLETION_FILE_DST, 'w') as dst:
            dst.write(rendered)

        xsys.stdout.write(rendered)
        return

    @classmethod
    def actions(cls):
        return [
            Xake.ACTION_INSTALL,
            Xake.ACTION_UNINSTALL,
            Xake.ACTION_STATUS,
            Xake.ACTION_COMPLETION,
        ]

    @classmethod
    def targets(cls):
        return [
            Xake.TARGET_DOTFILE,
            Xake.TARGET_BINFILE,
            Xake.TARGET_BREW,
            Xake.TARGET_CASK,
            Xake.TARGET_GEM,
            Xake.TARGET_NPM,
        ]

    @classmethod
    def __parser(cls):
        if xsys.version_info >= (2, 7, 0):
            return cls.__parser_27()
        else:
            return cls.__parser_26()

    @classmethod
    def __parser_27(cls):
        import argparse

        parser = argparse.ArgumentParser(formatter_class=lambda prog: argparse.HelpFormatter(prog, width=240))

        parser.add_argument("-n", "--dry-run", dest="dry_run", action="store_true", help="Do not execute commands actually")
        parser.add_argument("-v", "--verbose", dest="verbose", action="store_true", help="Show verbose messages")
        parser.add_argument("action", type=str, help="Action to perform: (%s)" % "|".join(cls.actions()))
        parser.add_argument("target", type=str, nargs="*", help="Target for action: (%s)" % "|".join(cls.targets()))

        return parser

    @classmethod
    def __parser_26(cls):
        import optparse

        parser = optparse.OptionParser(usage="Usage: %prog [options] <command> [<target> ...]")

        parser.add_option("-n", "--dry-run", dest="dry_run", action="store_true", help="Do not execute commands actually")
        parser.add_option("-v", "--verbose", dest="verbose", action="store_true", help="Show verbose messages")

        return parser

    def __context(self, args):
        """
        Package context

        :param args: Arguments
        :return: Context
        """
        if xsys.version_info >= (2, 7, 0):
            context = self.__context_27(args)
        else:
            context = self.__context_26(args)

        return context

    def __context_27(self, args):

        namespace = self.parser.parse_args(args)

        context = Context()
        context.action = namespace.action
        context.targets = namespace.target or ["dotfile"]
        context.dry_run = namespace.dry_run
        context.verbose = namespace.verbose

        return context

    def __context_26(self, args):

        (opts, argv) = self.parser.parse_args(args)

        context = Context()
        context.action = argv[0]
        context.targets = argv[1:] or ["dotfile"]
        context.dry_run = opts.dry_run
        context.verbose = opts.verbose

        return context

    @classmethod
    def __logger(cls, context):
        if context.verbose:
            logging_level = xlogging.DEBUG
        else:
            logging_level = xlogging.EXEC

        formatter = xlogging.LabelFormatter()

        handler = xlogging.StreamHandler()
        handler.setLevel(logging_level)
        handler.setFormatter(formatter)

        logger = xlogging.getLogger(__name__)
        logger.setLevel(logging_level)
        logger.addHandler(handler)

        return logger

    @classmethod
    def __commands(cls, context):
        if context.action == Xake.ACTION_INSTALL:
            return cls.__commands_install(context)

        if context.action == Xake.ACTION_UNINSTALL:
            return cls.__commands_uninstall(context)

        if context.action == Xake.ACTION_STATUS:
            return cls.__commands_status(context)

        return []

    @classmethod
    def __commands_install(cls, context):

        modules = filter(lambda module: module is not None and module.Install is not None,
                         map(lambda target: cls.__module(target), context.targets))

        commands = filter(lambda action: action is not None,
                          map(lambda module: module.Install(noop=context.dry_run, logger=context.logger), modules))

        return commands

    @classmethod
    def __commands_uninstall(cls, context):

        modules = filter(lambda module: module is not None and module.Uninstall is not None,
                         map(lambda target: cls.__module(target), context.targets))

        commands = filter(lambda action: action is not None,
                          map(lambda module: module.Uninstall(noop=context.dry_run, logger=context.logger), modules))

        return commands

    @classmethod
    def __commands_status(cls, contex):

        modules = filter(lambda module: module is not None and module.Status is not None,
                         map(lambda target: cls.__module(target), contex.targets))

        commands = filter(lambda action: action is not None,
                          map(lambda module: module.Status(noop=contex.dry_run, logger=contex.logger), modules))

        return commands

    @classmethod
    def __module(cls, target):
        if target == Xake.TARGET_DOTFILE:
            return vake.command.dotfile

        if target == Xake.TARGET_BREW:
            return vake.command.brew

        if target == Xake.TARGET_CASK:
            return vake.command.cask

        if target == Xake.TARGET_GEM:
            return vake.command.gem

        if target == Xake.TARGET_NPM:
            return vake.command.npm

        if target == Xake.TARGET_BINFILE:
            return vake.command.binfile

        return None


class Context:
    """
    Attributes store for application
    """

    def __init__(self):
        """
        Initialize context
        """
        self.action = None
        self.targets = []
        self.dry_run = False
        self.verbose = False
        self.logger = None
        return

#
# Main process
#
if __name__ == "__main__":
    # change to script's directory
    xos.chdir(xpath.dirname(xpath.realpath(__file__)))

    # run application
    Xake().run(xsys.argv[1:])
